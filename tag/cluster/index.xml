<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>cluster | Diego Castro | Pandora Box</title>
    <link>https://diegocastroviadero.com/tag/cluster/</link>
      <atom:link href="https://diegocastroviadero.com/tag/cluster/index.xml" rel="self" type="application/rss+xml" />
    <description>cluster</description>
    <generator>Source Themes Academic (https://sourcethemes.com/academic/)</generator><language>es-es</language><lastBuildDate>Sun, 27 Sep 2020 11:19:00 +0000</lastBuildDate>
    <image>
      <url>https://diegocastroviadero.com/images/icon_hu5b71f2ac8f47c835f06dc78dd1a89e98_16136_512x512_fill_lanczos_center_2.png</url>
      <title>cluster</title>
      <link>https://diegocastroviadero.com/tag/cluster/</link>
    </image>
    
    <item>
      <title>Monto un cluster Kubernetes con Raspberry Pi (parte II)</title>
      <link>https://diegocastroviadero.com/post/monto-un-cluster-kubernetes-con-rpi-parte-ii/</link>
      <pubDate>Sun, 27 Sep 2020 11:19:00 +0000</pubDate>
      <guid>https://diegocastroviadero.com/post/monto-un-cluster-kubernetes-con-rpi-parte-ii/</guid>
      <description>&lt;p&gt;Esta es una serie de posts en la que voy a explicar cómo he montado un cluster de Kubernetes utilizando Raspberry Pi y algún ejemplo de uso.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;a href=&#34;../monto-un-cluster-kubernetes-con-rpi-parte-i&#34;&gt;Parte I&lt;/a&gt; - Hardware&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Parte II - Sistema Operativo y Docker&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;Parte III - (proximamente)&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;sistema-operativo&#34;&gt;Sistema Operativo&lt;/h1&gt;
&lt;p&gt;Una vez que todo el hardware está montado la siguiente decisión a tomar es qué sistema operativo instalar en las Raspberry. En el momento de tomar la decisión barajaba 3 opciones:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Raspbian&lt;/li&gt;
&lt;li&gt;Hypriot&lt;/li&gt;
&lt;li&gt;Ubuntu&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;em&gt;Raspbian&lt;/em&gt; es la distribución oficial para raspberry, y sería una buena elección. Sin embargo, no me he decantado por esta opción, y la razón principal es que en el momento de tomar la decisión no había una versión final de 64 bits (estaba en beta).&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Hypriot&lt;/em&gt; es una distribución que desconocía totalmente y que viene con docker preinstalado, lo cual simplificaría el proceso de instalación y supondría un ahorro de tiempo. Tampoco me he decidido por esta opción, y el motivo es el mismo que con &lt;em&gt;Raspbian&lt;/em&gt;, no existe una versión de 64 bits.&lt;/p&gt;
&lt;p&gt;Tras haber descartado las dos distribuciones anteriores me entró la duda de si mi idea inicial de instalar una distribución de 64 bits era una buena idea. Inicialmente pensaba que con una distribución de 32 bits no podría aprovechar los 8 GB de RAM de las raspberry y de ahí que buscase una distribución de 64 bits. Tras investigar un poco, me di cuenta de que esto no era cierto del todo, con una distribución de 32 bits sí que se aprovecharían los 8 GB de RAM. Un mismo proceso del sistema operativo podría usar como mucho 4 GB de RAM, pero entre varios procesos se podrían consumir los 8 GB. Aún así, mantuve mi idea inicial de instalar una distribución de 64 bits, creo que no tiene sentido a día de hoy comenzar un proyecto optando por 32 bits, aunque esta elección traiga ciertas &amp;ldquo;ventajas&amp;rdquo; inicialmente.&lt;/p&gt;
&lt;p&gt;Finalmente descubrí que &lt;em&gt;Ubuntu&lt;/em&gt; tiene distribuciones para &lt;em&gt;ARM&lt;/em&gt; y que estas pueden ser de 64 bits. Así que - &amp;ldquo;Señores, ¡Ya tenemos caballo ganador!&amp;rdquo;.&lt;/p&gt;
&lt;p&gt;Con el sistema operativo elegido lo siguiente era:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;flashear las 5 tarjetas de memoria&lt;/li&gt;
&lt;li&gt;actualizar y realizar ciertas configuraciones en las 5 raspberry&lt;/li&gt;
&lt;li&gt;instalar Docker en las 5 raspberry&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;En estos momentos me arrepentí un poco de haber comprado 5 raspberry porque todo lo que fuese a hacer lo tenía que repetir 5 veces. Si tienes claro el proceso, es cuestión de seguirlo a pies juntillas y repetirlo las veces que sea necesario. El problema viene cuando el proceso no está claramente definido, y con cada repetición se va refinando el mismo. Este &amp;ldquo;ir refinando el proceso a medida que lo vas repitiendo&amp;rdquo; no debería ser algo problemático. El problema radica en mi persona y mi obsesión con algunas cosas, y en este caso mi obsesión no me permitiría sentirme cómodo sabiendo que no he ejecutado el mismo proceso en todas las raspberry. Si cuando estoy en la última raspberry me doy cuenta de que sería mejor hacer algo de forma diferente, me vería obligado a volver a hacerlo en todas las raspberry. Aquí es donde la situación podría descontrolarse y llevarme muchísimo más tiempo del necesario con la &lt;em&gt;única ventaja&lt;/em&gt; de tener todas las rapberry exactamente iguales.&lt;/p&gt;
&lt;p&gt;Antes de lanzarme a configurar las raspberry busqué la forma de automatizar todo el proceso de configuración, lo cual me permitiría dormir tranquilo sabiendo que todas las raspberry son &lt;em&gt;almas gemelas&lt;/em&gt; sin tener que repetir manualmente el proceso de configuración por enésima vez sobre la &lt;em&gt;oveja negra del rebaño&lt;/em&gt;. Y la búsqueda fue fructífera, me topé con 
&lt;a href=&#34;https://cloudinit.readthedocs.io&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Cloud-Init&lt;/a&gt; y con 
&lt;a href=&#34;https://docs.ansible.com&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Ansible&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&#34;cloud-init&#34;&gt;Cloud-Init&lt;/h2&gt;
&lt;p&gt;&lt;em&gt;Cloud-Init&lt;/em&gt; es una tecnología que permite inicializar una instancia y que viene de caja con Ubuntu. Cloud-Init detecta si es el primer arranque del sistema y si es el caso entra en acción permitiendo configurar: usuarios, claves ssh, particiones de disco, configuración de red, etc. Cloud-Init puede obtener las acciones que tiene que ejecutar del propio disco de la instacia o podría obtenerlo a través de la red.&lt;/p&gt;
&lt;p&gt;En mi caso, las acciones a actualizar las obtiene del propio disco: una vez flasheada la tarjeta SD copio un par de ficheros en la tarjeta con las configuraciones a realizar. Concretamente utilizo cloud-init para:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;actualizar los paquetes del sistema&lt;/li&gt;
&lt;li&gt;establecer el nombre de la instancia&lt;/li&gt;
&lt;li&gt;configurar el DNS&lt;/li&gt;
&lt;li&gt;desactivar la creación del usuario por defecto del sistema operativo&lt;/li&gt;
&lt;li&gt;crear un usuario específico&lt;/li&gt;
&lt;li&gt;establecer una clave SSH para el usuario&lt;/li&gt;
&lt;li&gt;deshabilitar el acceso al sistema con contraseña&lt;/li&gt;
&lt;li&gt;configuración de una ip fija&lt;/li&gt;
&lt;li&gt;instalación de paquetes adicionales: &lt;code&gt;curl&lt;/code&gt;, &lt;code&gt;vim&lt;/code&gt;, &lt;code&gt;git&lt;/code&gt; y &lt;code&gt;aptitude&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Este es un ejemplo de fichero de configuración de cloud-init de uno de los nodos del cluster:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;#cloud-config

preserve_hostname: false
hostname: rpicluster01
fqdn: rpicluster01.test

package_update: true
package_upgrade: true
package_reboot_if_required: true

manage_resolv_conf: true
resolv_conf:
  nameservers: [&#39;8.8.4.4&#39;, &#39;8.8.8.8&#39;]

users:
## Disable creation of default user
#- default
## Create user
- name: rpicluster
  homedir: /home/rpicluster
  lock_passwd: true
  shell: /bin/bash
  # Generate key with command: ssh-keygen -t rsa -b 4096 -C &amp;quot;your_email@example.com&amp;quot;
  ssh_authorized_keys:
    - **************************************************************************************
  sudo:
    - ALL=(ALL) NOPASSWD:ALL

## Disable password authentication with the SSH daemon
ssh_pwauth: false

## Install additional packages on first boot
packages:
- curl
- vim
- git
- aptitude

final_message: &amp;quot;The system is finally up, after $UPTIME seconds&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;La configuración de red se establece en otro fichero diferente que tiene la siguiente pinta:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;# This file contains a netplan-compatible configuration which cloud-init
# will apply on first-boot. Please refer to the cloud-init documentation and
# the netplan reference for full details:
#
# https://cloudinit.readthedocs.io/
# https://netplan.io/reference
#
# Some additional examples are commented out below

version: 2
ethernets:
  eth0:
    dhcp4: false
    addresses: [192.168.86.51/24]
    gateway4: 192.168.86.1
    mtu: 1500
    nameservers:
      addresses: [8.8.4.4, 8.8.8.8]
    optional: true
#wifis:
#  wlan0:
#    dhcp4: true
#    optional: true
#    access-points:
#      myhomewifi:
#        password: &amp;quot;S3kr1t&amp;quot;
#      myworkwifi:
#        password: &amp;quot;correct battery horse staple&amp;quot;
#      workssid:
#        auth:
#          key-management: eap
#          method: peap
#          identity: &amp;quot;me@example.com&amp;quot;
#          password: &amp;quot;passw0rd&amp;quot;
#          ca-certificate: /etc/my_ca.pem
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Para flashear la imagen del sistema operativo en la tarjeta SD utilizo 
&lt;a href=&#34;https://www.raspberrypi.org/blog/raspberry-pi-imager-imaging-utility&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;rpiimager&lt;/a&gt;. Esta herramienta te provee de una interfaz gráfica muy sencilla en la que en primer lugar se selecciona la imagen que quieres flashear, en segundo lugar se elige dónde la quieres flashear y por último se inicia la grabación. Esta herramienta te evita tener que descargar la imagen del sistema operativo ya que es la propia herramienta quien se encarga de descargarla.&lt;/p&gt;
&lt;p&gt;Al arrancar la raspberry por primera vez cloud-init se activará y ejecutará las acciones anteriores, lo único que hay que hacer es esperar unos minutos. Alguien perspicaz, se habrá dado cuenta que hay dos acciones en la lista anterior que no son iguales para todas las raspberry del cluster: establecer el nombre de la instancia y configurar una ip fija. Esto hace que haya que tener para cada instancia del cluster un fichero de configuración diferente. Y en este punto es donde entra en acción &lt;em&gt;Ansible&lt;/em&gt;.&lt;/p&gt;
&lt;h2 id=&#34;ansible&#34;&gt;Ansible&lt;/h2&gt;
&lt;p&gt;&lt;em&gt;Ansible&lt;/em&gt;, resumiéndolo mucho, es una herramienta de automatización de tareas. Dado un fichero de inventario, en el que se definen una serie de máquinas; y un fichero de tareas (&lt;em&gt;playbook&lt;/em&gt;), en el que se definen una serie de tareas; Ansible se encargará de ejecutar cada una de las tareas en cada una de las máquinas. Con el añadido de que la ejecución de dichas tareas es &lt;em&gt;idempotente&lt;/em&gt;, es decir, que si alguna de las tareas ya se ha ejecutado en alguna de dichas máquinas, no la volverá a ejecutar. Esto es una simplificación muy grande de todo el universo de Ansible, pero en este post no quiero entrar en detalles sobre Ansible, sino en explicar lo mínimo para que se entienda de qué forma se ha utilizado esta herramienta para montar el cluster.&lt;/p&gt;
&lt;p&gt;Como he mencionado anteriormente, he utilizado Ansible para la generación de los ficheros de configuración de cloud-init. Y este es un caso de uso un poco especial, puesto que no se ajusta a la descripción anterior sobre el funcionamiento básico de Ansible. Sí que disponemos de un fichero de inventario, pero no utilizamos Ansible para ejecutar ninguna tarea sobre las máquinas del inventario, sino para obtener unos datos sobre dichas máquinas y utilizarlos para generar unos ficheros de configuración en el puesto local.&lt;/p&gt;
&lt;p&gt;Este es un extracto del fichero de inventario:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-ini&#34;&gt;[rpicluster01]
192.168.86.51

[rpicluster01:vars]
custom_hostname=rpicluster01


[rpicluster02]
192.168.86.52

[rpicluster02:vars]
custom_hostname=rpicluster02


[rpicluster03]
192.168.86.53

[rpicluster03:vars]
custom_hostname=rpicluster03


[rpicluster04]
192.168.86.54

[rpicluster04:vars]
custom_hostname=rpicluster04


[rpicluster05]
192.168.86.55

[rpicluster05:vars]
custom_hostname=rpicluster05


[rpicluster:children]
rpicluster01
rpicluster02
rpicluster03
rpicluster04
rpicluster05
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;En este caso hemos definido el inventario en un fichero en formato &lt;code&gt;INI&lt;/code&gt;. Se puede ver que se han definido varios grupos. Hay un grupo con un solo elemento para cada una de las máquinas del cluster y así poder hacer referencia a una máquina concreta:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;rpicluster01&lt;/li&gt;
&lt;li&gt;rpicluster02&lt;/li&gt;
&lt;li&gt;rpicluster03&lt;/li&gt;
&lt;li&gt;rpicluster04&lt;/li&gt;
&lt;li&gt;rpicluster05&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;También hay un grupo que está compuesto por todas las máquinas del cluster, para poder hacer referencia a todo el cluster:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;rpicluster&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Para cada una de las máquinas se define una propiedad &lt;code&gt;custom_hostname&lt;/code&gt; que contiene el nombre de la máquina.&lt;/p&gt;
&lt;p&gt;(se puede ver el fichero completo 
&lt;a href=&#34;https://github.com/dicastro/rpicluster/blob/master/playbooks/inventory&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;aquí&lt;/a&gt;)&lt;/p&gt;
&lt;p&gt;A continuación se muestra el &lt;em&gt;playbook&lt;/em&gt; de ansible que genera los ficheros de configuración de cloud-init para las máquinas del cluster:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;---
- hosts: rpicluster
  gather_facts: false
  tasks:
    - name: create directories
      file:
        path: &amp;quot;../../cloud-init/{{ hostvars[inventory_hostname][&#39;custom_hostname&#39;] }}&amp;quot;
        state: directory
      delegate_to: localhost

    - name: generate user-data config file from template
      template:
        src: template_userdata.j2
        dest: &amp;quot;../../cloud-init/{{ hostvars[inventory_hostname][&#39;custom_hostname&#39;] }}/user-data&amp;quot;
      delegate_to: localhost

    - name: generate network-config file from template
      template:
        src: template_networkconfig.j2
        dest: &amp;quot;../../cloud-init/{{ hostvars[inventory_hostname][&#39;custom_hostname&#39;] }}/network-config&amp;quot;
      delegate_to: localhost
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Se definen 3 tareas:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;La tarea 1 se encarga de crear un directorio para cada una de las máquinas del inventario&lt;/li&gt;
&lt;li&gt;La tarea 2 genera el fichero de configuración &lt;code&gt;user-data&lt;/code&gt; a partir de un template&lt;/li&gt;
&lt;li&gt;La tarea 3 genera el fichero de configuración &lt;code&gt;network-config&lt;/code&gt; a partir de un template&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;(se puede ver el playbook completo 
&lt;a href=&#34;https://github.com/dicastro/rpicluster/tree/master/playbooks/00_cluster_regenerate_cloudinit_config&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;aquí&lt;/a&gt;)&lt;/p&gt;
&lt;h1 id=&#34;docker&#34;&gt;Docker&lt;/h1&gt;
&lt;p&gt;Gracias a Ansible, la instalación de Docker en todas las máquinas se ha simplificado al máximo. He encontrado un playbook, que he utilizado casi tal cual, que se encarga de instalar Docker en sistemas debian. Se puede encontrar la versión que he utilizado 
&lt;a href=&#34;https://github.com/dicastro/rpicluster/tree/master/playbooks/02_cluster_install_docker&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;aquí&lt;/a&gt;.&lt;/p&gt;
&lt;h1 id=&#34;conclusión&#34;&gt;Conclusión&lt;/h1&gt;
&lt;p&gt;Como conclusión he de decir que tanto &lt;em&gt;cloud-init&lt;/em&gt; como &lt;em&gt;Ansible&lt;/em&gt; han sido dos grandes descubrimientos. Sobre todo Ansible, ya que veo que es una herramienta que puedo empezar a utilizar en mi día a día a nivel profesional.&lt;/p&gt;
&lt;p&gt;La única pega que le veo a Ansible, es que algunos aspectos no son compatibles con Windows. Actualmente utilizo un Windows 10 y he podido hacer uso de Ansible sin grandes complicaciones a través de WLS. El único inconveniente que me he topado hasta el momento, ha sido a la hora de utilizar &lt;em&gt;Ansible Vault&lt;/em&gt;, ya que para ciertas situaciones es necesario modificar los permisos de algunos ficheros, lo cual no es posible en WLS a día de hoy (o al menos yo no he encontrado la manera de hacerlo).&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Monto un cluster Kubernetes con Raspberry Pi (parte I)</title>
      <link>https://diegocastroviadero.com/post/monto-un-cluster-kubernetes-con-rpi-parte-i/</link>
      <pubDate>Fri, 18 Sep 2020 15:31:00 +0000</pubDate>
      <guid>https://diegocastroviadero.com/post/monto-un-cluster-kubernetes-con-rpi-parte-i/</guid>
      <description>&lt;p&gt;Esta es una serie de posts en la que voy a explicar cómo he montado un cluster de Kubernetes utilizando Raspberry Pi y algún ejemplo de uso.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Parte I - Hardware&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;
&lt;a href=&#34;../monto-un-cluster-kubernetes-con-rpi-parte-ii&#34;&gt;Parte II&lt;/a&gt; - Sistema Operativo y Docker&lt;/li&gt;
&lt;li&gt;Parte III - (proximamente)&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;introducción&#34;&gt;Introducción&lt;/h1&gt;
&lt;p&gt;Kubernetes es una tecnología de orquestación de contenedores que lleva en el mercado ya varios años. Sin embargo, hasta la fecha, no he tenido la oportunidad de &amp;ldquo;jugar&amp;rdquo; con ella. Llevo varios años trabajando intensamente con Docker, y tenía como asignatura pendiente empezar a utilizar algún orquestador de contenedores. Como a nivel profesional no he tenido la ocasión de hacerlo, y como pienso que como mejor se aprende es practicando, nada mejor para aprender Kubernetes, que montarme un cluster Kubernetes desde cero. Quizás llegue un poco tarde, pero creo que es mejor tarde que nunca.&lt;/p&gt;
&lt;p&gt;Finalmente me he decidido por montar un cluster &lt;em&gt;on premise&lt;/em&gt; en mi casa. Al principio pensé que lo más sencillo, rápido y barato sería hacerlo en el cloud, pero lo cierto es que me daba mucha pereza. Demasiados proveedores, cada uno con unos servicios gratuitos, con unas condiciones de pago por uso diferentes, en alguno de los cuales ya había consumido dicho uso gratuito, etc.&lt;/p&gt;
&lt;p&gt;Aunque montar un cluster &lt;em&gt;on premise&lt;/em&gt; suponga un desembolso inicial superior y un mayor esfuerzo, frente a montarlo en el cloud, encuentro al menos dos motivos que han hecho que me decline por esta opción.&lt;/p&gt;
&lt;p&gt;En primer lugar, considero que montando el cluster &lt;em&gt;on premise&lt;/em&gt; me puede simplificar el aprendizaje de los conceptos básicos, ya que no me veré distraído por la terminología y servicios accesorios varios ofrecidos por los proveedores cloud.&lt;/p&gt;
&lt;p&gt;En segundo lugar, me da mucha tranquilidad saber que si lo apago no consumo nada. Sé que este argumento puede no tener mucho sentido, ya que en el cloud, uno tiene control sobre los servicios que contrata y también podría &amp;ldquo;apagarlo&amp;rdquo; en cualquier momento. La cosa es que el mundo de los proveedores cloud también es nuevo para mí, y el sistema de facturación me parece un poco complejo. Sería otra cosa desconocida adicional a la que enfrentarme. Mi objetivo inicial es aprender Kubernetes, no es conocer como montar un cluster kubernetes en Amazon, Google o Azure y cuánto me van a cobrar por ello. En el pasado ya he tenido algún susto con grandes facturas de proveedores cloud, por creer que estaba haciendo uso de los servicios gratuitos, cuando no era cierto.&lt;/p&gt;
&lt;h1 id=&#34;componentes&#34;&gt;Componentes&lt;/h1&gt;
&lt;p&gt;El cluster está compuesto inicialmente de 5 
&lt;a href=&#34;https://www.tiendatec.es/raspberry-pi/placas-base/1231-raspberry-pi-4-modelo-b-8gb-765756931199.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Raspberry Pi modelo 4b con 8GB de RAM&lt;/a&gt;. Esto hace que el cluster disponga de:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;20 cores a 1&#39;5 GHz&lt;/li&gt;
&lt;li&gt;40 GB de memoia RAM&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Cada Raspberry tiene una tarjeta de memoria microSD 
&lt;a href=&#34;https://www.amazon.es/gp/product/B06XFSZGCC/ref=ppx_yo_dt_b_asin_title_o03_s00&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Samsung EVO Plus de 32GB&lt;/a&gt;. Este almacenamiento será únicamente para la ejecución del sistema operativo. Inicialmente también lo utilizaré para la persistencia de los contenedores del cluster. Más adelante cuando me adentre en el mundo de los volúmenes persistentes, montaré un mecanismo de persistencia dedicado.&lt;/p&gt;
&lt;p&gt;Con el objetivo de facilizar el montaje del cluster y reducir el número de clables necesarios, he comprado unos módulos 
&lt;a href=&#34;https://www.tiendatec.es/raspberry-pi/hats/757-raspberry-pi-hat-poe-r20-0652508442105.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;HAT PoE&lt;/a&gt; que me permiten alimentar las Raspberry por PoE. De esta forma puedo prescindir de los transformadores y los cables USB para alimentar las Raspberry, ya que con el mismo cable ethernet alimento las Raspberry y les proporciono conexión de red.&lt;/p&gt;
&lt;p&gt;Para poder alimentar las Raspberry por PoE he comprado un switch 
&lt;a href=&#34;https://www.amazon.es/gp/product/B076BV421P/ref=ppx_yo_dt_b_asin_title_o04_s00&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Netgear GS108PP&lt;/a&gt; con 8 puertos y con alimentación PoE en todos. Esto me permite tener hasta 7 Raspberry alimentadas y conectadas, ya que uno de los puertos lo utilizo para conectar el switch a la red.&lt;/p&gt;
&lt;p&gt;Para albergar todos los componentes he comprado un armario rack de 19&amp;rdquo; 
&lt;a href=&#34;https://www.amazon.es/gp/product/B00D5T3TDS/ref=ppx_yo_dt_b_asin_title_o04_s02&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Phasak PHP 2106&lt;/a&gt;. El armario tiene 6U de espacio en total que será utilizado de la siguiente forma:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;1U para una 
&lt;a href=&#34;https://www.amazon.es/gp/product/B00X44HTY4/ref=ppx_yo_dt_b_asin_title_o04_s01&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;reglega de 8 tomas con interruptor&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;1U para el switch que va sobre una 
&lt;a href=&#34;https://www.amazon.es/gp/product/B001PKPK1I/ref=ppx_yo_dt_b_asin_title_o04_s01&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;bandeja&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;2U para alojar hasta 12 Raspberry Pi&lt;/li&gt;
&lt;li&gt;2U libres&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Para colocar todas las Raspberry en fila en el armario rack, he imprimido 
&lt;a href=&#34;https://www.thingiverse.com/thing:4078710&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;este proyecto&lt;/a&gt;, disponible en Thingiverse. Ocupando 2U del rack se pueden tener 12 Raspberry. Cada Raspberry está en una bandeja extraíble, haciendo muy sencillo una sustitución. La mayoría de ejemplos que había visto para apilar Raspberry, lo hacian de tal forma que el recambio de una de ellas implicaría desmontar todo. Este es uno de los pocos que he encontrado que facilita el mantenimiento.&lt;/p&gt;
&lt;p&gt;Antes de poner el cluster en funcionamiento de forma continuada me gustaría tener un mecanismo para medir el consumo del mismo. Tengo pendiente comprar algún dispositivo que me permita medir el consumo y tener algún tipo de histórico para calcular su coste. He hecho una búsqueda rápida y he visto un montón de enchufes baratos que miden el consumo, aunque ninguno me ha convencido. Me gustaría tener una solución que se integre con 
&lt;a href=&#34;https://www.home-assistant.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Home Assistant&lt;/a&gt;, que es la solución que tengo en casa para la domótica. Este aspecto queda fuera del ámbito de este post y no me extenderé más en ello.&lt;/p&gt;
&lt;h1 id=&#34;conclusión&#34;&gt;Conclusión&lt;/h1&gt;
&lt;p&gt;La combinación de estos componentes me permite tener un cluster:&lt;/p&gt;
&lt;h4 id=&#34;compacto&#34;&gt;Compacto&lt;/h4&gt;
&lt;p&gt;El armario rack de 19&amp;rdquo; y 6U es un armario de reducidas dimensiones que puedo colocar en cualquier sitio de la casa.&lt;/p&gt;
&lt;h4 id=&#34;ventilado&#34;&gt;Ventilado&lt;/h4&gt;
&lt;p&gt;El armario rack dispone de 2 grandes ventiladores en la parte superior. Además cada Raspberry dispone de un ventilador ya que el &lt;em&gt;HAT PoE&lt;/em&gt; incluye uno. Creo que es ventilación suficiente para dejar el cluster encendido de continuo sin miedo a que se sobrecaliente.&lt;/p&gt;
&lt;h4 id=&#34;ordenado&#34;&gt;Ordenado&lt;/h4&gt;
&lt;p&gt;Los &lt;em&gt;HAT PoE&lt;/em&gt; han ayudado mucho a que el armario no tenga demasiados cables en su interior y a que la regleta tenga más tomas disponibles para su uso.&lt;/p&gt;
&lt;h4 id=&#34;iluminado&#34;&gt;Iluminado&lt;/h4&gt;
&lt;p&gt;El armario rack dispone también de iluminación led, esto me da libertad para poder situar el armario rack en cualquier punto de la casa y poder hacer un mantenimiento del mismo sin problemas de falta de luz.&lt;/p&gt;
&lt;h4 id=&#34;extensible&#34;&gt;Extensible&lt;/h4&gt;
&lt;p&gt;Gracias al proyecto de thingiverse puedo colocar hasta 12 Rasperry ocupando 2U del armario. Con las 2U que me quedan libres podría:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Colocar otras 12 raspberry pi&lt;/li&gt;
&lt;li&gt;Colocar algún dispositivo SAI&lt;/li&gt;
&lt;li&gt;Dedicarlo a almacenamiento&lt;/li&gt;
&lt;li&gt;etc&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;bom&#34;&gt;BOM&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;5x 
&lt;a href=&#34;https://www.tiendatec.es/raspberry-pi/placas-base/1231-raspberry-pi-4-modelo-b-8gb-765756931199.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Raspberry Pi modelo 4b con 8GB de RAM&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;5x 
&lt;a href=&#34;https://www.amazon.es/gp/product/B06XFSZGCC/ref=ppx_yo_dt_b_asin_title_o03_s00&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Samsung EVO Plus de 32GB&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;5x 
&lt;a href=&#34;https://www.tiendatec.es/raspberry-pi/hats/757-raspberry-pi-hat-poe-r20-0652508442105.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;HAT PoE&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;1x 
&lt;a href=&#34;https://www.amazon.es/gp/product/B076BV421P/ref=ppx_yo_dt_b_asin_title_o04_s00&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Netgear GS108PP&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;1x 
&lt;a href=&#34;https://www.amazon.es/gp/product/B00D5T3TDS/ref=ppx_yo_dt_b_asin_title_o04_s02&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Phasak PHP 2106&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;1x 
&lt;a href=&#34;https://www.amazon.es/gp/product/B00X44HTY4/ref=ppx_yo_dt_b_asin_title_o04_s01&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Reglega de 8 tomas con interruptor&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;1x 
&lt;a href=&#34;https://www.amazon.es/gp/product/B001PKPK1I/ref=ppx_yo_dt_b_asin_title_o04_s01&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Bandeja&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;1x 
&lt;a href=&#34;https://www.amazon.es/gp/product/B0046UCVFM/ref=ppx_yo_dt_b_asin_title_o03_s01&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Cables de red de 25cm&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;1x 
&lt;a href=&#34;https://www.amazon.es/gp/product/B073WDSPS8/ref=ppx_yo_dt_b_asin_title_o03_s01&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Tornillos y tuercas para armario rack&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;1x 
&lt;a href=&#34;https://www.amazon.es/gp/product/B081JJ2LRT/ref=ppx_yo_dt_b_asin_title_o00_s00?ie=UTF8&amp;amp;psc=1&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Tornillos M2.5 para Raspberry Pi&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;2x Varilla roscada M4 de 1m (&lt;em&gt;comprado en ferretería&lt;/em&gt;)&lt;/li&gt;
&lt;li&gt;8x Tuercas M4 (&lt;em&gt;comprado en ferretería&lt;/em&gt;)&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
  </channel>
</rss>
