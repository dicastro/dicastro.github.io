<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>home assistant | Diego Castro | Pandora Box</title>
    <link>https://diegocastroviadero.com/tag/home-assistant/</link>
      <atom:link href="https://diegocastroviadero.com/tag/home-assistant/index.xml" rel="self" type="application/rss+xml" />
    <description>home assistant</description>
    <generator>Wowchemy (https://wowchemy.com)</generator><language>es-es</language><lastBuildDate>Tue, 20 Oct 2020 16:44:00 +0000</lastBuildDate>
    <image>
      <url>https://diegocastroviadero.com/media/logo_hu5b71f2ac8f47c835f06dc78dd1a89e98_16136_300x300_fit_lanczos_3.png</url>
      <title>home assistant</title>
      <link>https://diegocastroviadero.com/tag/home-assistant/</link>
    </image>
    
    <item>
      <title>Cómo exponer una instalación casera de Home Assistant a Internet</title>
      <link>https://diegocastroviadero.com/post/como-exponer-homeassistant-a-internet/</link>
      <pubDate>Tue, 20 Oct 2020 16:44:00 +0000</pubDate>
      <guid>https://diegocastroviadero.com/post/como-exponer-homeassistant-a-internet/</guid>
      <description>&lt;p&gt;En este post explicaré cómo expongo mi &lt;strong&gt;instalación local&lt;/strong&gt; de &lt;a href=&#34;https://www.home-assistant.io&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Home Assistant&lt;/a&gt; a Internet a través de un &lt;strong&gt;dominio propio&lt;/strong&gt; y de forma &lt;strong&gt;segura&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;La &lt;em&gt;instalación local&lt;/em&gt; de Home Assistant no es más que una raspberry pi conectada al router de mi proveedor de internet.&lt;/p&gt;
&lt;p&gt;El &lt;em&gt;dominio propio&lt;/em&gt; es un dominio adquirido en &lt;a href=&#34;https://domains.google.com&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;google domains&lt;/a&gt;, concretamente se trata del dominio &lt;code&gt;popishome.com&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;El acceso al Home Assistant es &lt;em&gt;seguro&lt;/em&gt; porque se va a realizar utilizando el protocolo HTTPs. Se cifrará la conexión con un certificado de &lt;a href=&#34;https://letsencrypt.org&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Let&amp;rsquo;s Encrypt&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Con estos mimbres se plantean varias cuestiones:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;La raspberry pi está conectada al router del proveedor a internet por lo que la manera de llegar a la raspberry será utilizando la IP que el provedor de internet me haya asignado. En mi caso, dicha dirección IP puede variar al antojo del proveedor ya que no tengo contratada una IP fija. La cuestión que se plantea es ¿Cómo conseguir que el dominio apunte contínuamente a la IP que tengo asignada en cada momento? ¿Qué pasa cuando el proveedor de internet me cambia la IP?&lt;/li&gt;
&lt;li&gt;Let&amp;rsquo;s Encrypt lanza un desafío para obtener un certificado, que normalmente requiere de un acceso por http al puerto 80 de quien inicia el desafío, que en este caso sería la raspberry. Sin embargo, algunos proveedores de internet tienen el puerto 80 reservado y no dejan abrirlo ¿Cómo solventar dicho inconveniente?&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;La primera cuestión la podríamos resolver creando en Google Domains un &lt;code&gt;Dynamic DNS&lt;/code&gt; para nuestro dominio y obteniendo unos credenciales para el mismo.&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;./resources/dynamic_domain.png&#34; alt=&#34;Crear un Dynamic DNS en Google Domains&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;A continuación se configuraría en el Home Assistant el módulo de Google Domains para que actualice periódicamente los registros del DNS con la IP que tengamos asignada en cada momento.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;# Example configuration.yaml entry
google_domains:
  domain: subdomain.domain.com
  username: YOUR_USERNAME
  password: YOUR_PASSWORD
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Sin embargo, de esta forma únicamente se resuelve la primera de las cuestiones. Me gustaría disponer de una misma solución para solventar ambas cuestiones: &lt;a href=&#34;https://www.cloudflare.com&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Cloudflare&lt;/a&gt; al rescate!&lt;/p&gt;
&lt;h1 id=&#34;cloudflare&#34;&gt;Cloudflare&lt;/h1&gt;
&lt;p&gt;&lt;em&gt;Cloudflare&lt;/em&gt; es una red de entrega de contenido (CDN) que nos va a permitir resolver las dos cuestiones que se plantean al inicio. Por un lado tiene un api que permitirá a la raspberry pi notificar de forma periódica cuál es su dirección IP. Y por otro lado también expone un API que permite realizar un desafío DNS para la obtención del certificado, en lugar del habitual desafío http.&lt;/p&gt;
&lt;p&gt;Una vez registrados en Cloudflare, se accede a la cuenta y se da de alta el dominio propio de Google Domains:&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;./resources/cloudflare_new_site.png&#34; alt=&#34;Añadir nuestro dominio en Cloudflare&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;Al dar de alta el nuevo sitio lo haremos con la siguiente configuración:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Acceso directo (opción &lt;code&gt;DNS Only&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;Sin SSL&lt;/li&gt;
&lt;li&gt;Sin DNSSEC&lt;/li&gt;
&lt;li&gt;Sin ningún tipo de optimización de javascript&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Una vez dado de alta el sitio, habrá que configurar en el dominio de Google Domains los nameserver que se indiquen en Cloudflare:&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;./resources/cloudflare_nameservers.png&#34; alt=&#34;Nameservers en Cloudflare&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;./resources/google_domains_nameservers.png&#34; alt=&#34;Nameservers en Google Domains&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;Con todo esto, pasaremos a configurar el módulo de Cloudflare en el Home Assistant:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;cloudflare:
  email: &amp;lt;EMAIL&amp;gt;
  api_key: !secret cloudflare_globalapikey
  zone: popishome.com
  records:
    - domotic
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;El &lt;code&gt;api_key&lt;/code&gt; se corresponde al &lt;code&gt;Global Api Key&lt;/code&gt; y lo obtenemos de la configuración del perfil (&lt;em&gt;My Profile&lt;/em&gt;) en Cloudflare:&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;./resources/cloudflare_global_api_key.png&#34; alt=&#34;Global api key en Cloudflare&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;Con esta configuración se ha resuelto la primera de las cuestiones. Home Assistant notificará periódicamente la IP a Cloudflare y actualizará los registros DNS consecuentemente.&lt;/p&gt;
&lt;p&gt;Para resolver la segunda cuestión utilizaré un &lt;em&gt;add-on&lt;/em&gt; de Home Assistant, concretamente he utilizado &lt;code&gt;NGINX Proxy Manager&lt;/code&gt;. He seleccionado este add-on y no el oficial de NGINX, porque me resulta más sencillo de configurar y porque se integra con Cloudflare. Este add-on permite obtener fácilmente certificados de Let&amp;rsquo;s Encrypt y en lugar de pasar el habitual desafío HTTP se puede indicar que sea mediante un desafío DNS. El desafío DNS consiste simplemente en añadir de forma temporal unos registros DNS para que Let&amp;rsquo;s Encrypt pueda comprobar que estamos en posesión del dominio. Para poder añadir estos registros temporales hay que disponer de un token con permisos para editar el DNS en Cloudflare.&lt;/p&gt;
&lt;p&gt;La generación de un token con los permisos necesarios se hará desde &lt;em&gt;My Profile&lt;/em&gt; de Cloudflare:&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;./resources/cloudflare_api_token.png&#34; alt=&#34;Token con permisos para editar DNS en Cloudflare&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;Una vez generado el token, desde la pantalla de administración del add-on NGINX Proxy Manager se genera un nuevo certificado:&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;./resources/nginx_proxy_manager_ssl_cert.png&#34; alt=&#34;Nuevo certificado SSL en NGINX Proxy Manager&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;Ya con el certificado generado, configuramos un nuevo proxy para el Home Assistant:&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;./resources/nginx_proxy_manager_host_details.png&#34; alt=&#34;Nuevo Proxy Host en NGINX Proxy Manager&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;Y finalmente, configuramos SSL para dicho host, utilizando el certificado que hemos generado anteriormente:&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;./resources/nginx_proxy_manager_host_ssl.png&#34; alt=&#34;Configuracion SSL para el Proxy Host en NGINX Proxy Manager&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;Lo último que queda por realizar, es abrir en el router del proveedor a internet el puerto configurado en el NGINX Proxy Manager para el protocolo HTTPs:&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;./resources/nginx_proxy_manager_config.png&#34; alt=&#34;Configuracion de puertos de NGINX Proxy Manager&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;En mi caso particular he tenido que realizar un paso extra porque estoy utilizando Google WiFi en casa y tengo creada una red interna. He tenido que mapear el puerto de la red &amp;ldquo;externa&amp;rdquo; (la del router del proveedor a internet) y la red &amp;ldquo;interna&amp;rdquo; (la creada por Google WiFi y en la que está conectada la raspberry con el Home Assistant)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;Quería poner el enlace a Google WiFi pero no lo encuentro. Me he acordado de que era un producto que no se vendía en Europa y me lo trajeron de USA (parece que sigue sin venderse aquí). Sí que he encontrado &lt;a href=&#34;https://store.google.com/product/nest_wifi&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Nest WiFi&lt;/a&gt; que tiene pinta de ser lo mismo pero comercializado bajo la marca Nest.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&#34;conclusión&#34;&gt;Conclusión&lt;/h1&gt;
&lt;p&gt;Mediante el uso de Cloudflare he sido capaz de resolver las 2 cuestiones que se me planteaban al principio. Por un lado se actualiza la IP de la raspberry en los registros DNS del dominio propio. Y por otro lado se obtienen certificados de Let&amp;rsquo;s Encrypt para el dominio propio y se utilizan para establecer una conexión segura. No lo he mencionado hasta el momento, pero la funcionalidad de Cloudflare que he utilizado no tiene coste alguno.&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;./resources/homeassistant_secure.png&#34; alt=&#34;Acceso seguro a Home Assistant a través de un dominio propio&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Monto un cluster Kubernetes con Raspberry Pi (parte IV)</title>
      <link>https://diegocastroviadero.com/post/monto-un-cluster-kubernetes-con-rpi-parte-iv/</link>
      <pubDate>Wed, 14 Oct 2020 17:09:00 +0000</pubDate>
      <guid>https://diegocastroviadero.com/post/monto-un-cluster-kubernetes-con-rpi-parte-iv/</guid>
      <description>&lt;p&gt;Esta es una serie de posts en la que voy a explicar cómo he montado un cluster de Kubernetes utilizando Raspberry Pi y algún ejemplo de uso.&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Parte&lt;/th&gt;
&lt;th&gt;Título&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;../monto-un-cluster-kubernetes-con-rpi-parte-i&#34;&gt;P01&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Hardware&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;../monto-un-cluster-kubernetes-con-rpi-parte-ii&#34;&gt;P02&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Sistema Operativo y Docker&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;../monto-un-cluster-kubernetes-con-rpi-parte-iii&#34;&gt;P03&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Cluster K3S&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;P04&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;Consumo eléctrico&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;../monto-un-cluster-kubernetes-con-rpi-parte-v&#34;&gt;P05&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Monitorización&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;P06&lt;/td&gt;
&lt;td&gt;(proximamente)&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h1 id=&#34;introducción&#34;&gt;Introducción&lt;/h1&gt;
&lt;p&gt;En un post anterior de esta serie ya mencioné la primera disyuntiva a la que me enfrenté: &lt;a href=&#34;../monto-un-cluster-kubernetes-con-rpi-parte-i/#introducci%c3%b3n&#34;&gt;cloud vs. on premise&lt;/a&gt;. En ese momento tuve en cuenta los costes de ambas alternativas, aunque la comparativa fue poco precisa, ya que para la opción &lt;em&gt;on premise&lt;/em&gt; no tuve en cuenta el coste eléctrico para mantener el cluster encendido. Es por esto que desde entonces he buscado la manera de medir el gasto eléctrico del cluster.&lt;/p&gt;
&lt;p&gt;Desde un principio era totalmente consciente de que el proyecto del cluster me iba a llevar varios meses, y eso teniendo únicamente en cuenta únicamente el tiempo de investigación, prueba y aprendizaje. Si evoluciona como espero, el cluster se convertirá en una pieza central y tendrá un uso continuado. Mi intención es utilizarlo para ejecutar en él algunas aplicaciones que uso habitualmente y que tengo desperdigadas en varias raspberry por la casa, como por ejemplo el Home Assistant que se menciona en este post.&lt;/p&gt;
&lt;p&gt;Teniendo en cuenta que el cluster va a estar en funcionamiento ininterrumpidamente, considero que sería muy interesante medir el consumo eléctrico y calcular su coste. De esta forma podría hacer una comparativa más precisa entre el coste de un cluster en el cloud y el coste de este cluster.&lt;/p&gt;
&lt;h1 id=&#34;cómo-medir-el-consumo-eléctrico&#34;&gt;¿Cómo medir el consumo eléctrico?&lt;/h1&gt;
&lt;p&gt;Para medir el consumo del cluster me he decantado por un &lt;a href=&#34;https://www.amazon.es/gp/product/B07C864DSZ/ref=ppx_yo_dt_b_asin_title_o05_s01&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Sonoff Pow R2&lt;/a&gt;. Lo he colocado &amp;ldquo;antes&amp;rdquo; de la regleta que alimenta todos los elementos del cluster. De esta forma toda la corriente necesaria para hacer funcionar el cluster: luces, ventilación, raspberry, switch&amp;hellip; pasará a través del Sonoff y podrá ser contabilizada de forma global.&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;./resources/sonoff_en_cluster_resized.jpg&#34; alt=&#34;Sonoff Pow R2 en cluster&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;Para acoplar el Sonoff a la caja del cluster he diseñado &lt;a href=&#34;#piezas-para-la-caja-del-cluster&#34;&gt;unas piezas&lt;/a&gt; y las he imprimido con mi impresora 3D. He decidido inicialmente dejar el Sonoff en el exterior para tener una mejor cobertura WiFi ¿La caja del cluster actuaría como una &lt;a href=&#34;https://en.wikipedia.org/wiki/Faraday_cage&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;caja Faraday&lt;/a&gt;? En este caso he preferido ser pruedente y dejarlo incialmente por fuera, aunque no sea lo más estético. En un futuro quizás me anime a rediseñar las piezas para dejar el Sonoff en el interior de la caja del cluster.&lt;/p&gt;
&lt;p&gt;De nada sirve medir el consumo si no se realiza un registro del mismo. Para realizar el registro del consumo eléctrico contabilizado por el Sonoff he aprovechado una instancia de &lt;a href=&#34;https://www.home-assistant.io&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Home Assistant&lt;/a&gt; que tengo para la domótica de mi casa. De esta forma puedo disponer fácilmente de un panel para visualizar dicho consumo. En este post no voy a explicar cómo instalar Home Assistant, aunque sí que voy a describir algunas de las configuraciones que he tenido que cambiar.&lt;/p&gt;
&lt;h1 id=&#34;sonoff-pow-r2&#34;&gt;Sonoff Pow R2&lt;/h1&gt;
&lt;p&gt;Este es un dispositivo barato que podría definirse como un interruptor &amp;ldquo;inteligente&amp;rdquo; que puede controlarse via WiFi y que permite medir el consumo eléctrico. En este caso no lo utilizo como interruptor, sino únicamente lo uso para medir el consumo. La forma de &amp;ldquo;anular&amp;rdquo; el interruptor (con software) es configurarlo de tal forma que esté siempre &amp;ldquo;encendido&amp;rdquo;. Otra forma más invasiva de conserguirlo sería desoldar el relay y puentearlo.&lt;/p&gt;
&lt;p&gt;Sonoff proporciona una aplicación móvil a través de la cual se pueden controlar los diferentes dispositivos de la marca, programarlos y visualizar la información que generan. Para que todo esto sea posible, la información generada por los dispositivos viaja hasta los servidores de la empresa y desde ahí a los dispositivos móviles.&lt;/p&gt;
&lt;p&gt;Sin embargo, ni me interesa que mis datos pasen por un servidor de un tercero, ni tengo interés en usar una aplicación móvil adicional, porque lo que quiero es integrarlo con Home Assistant. La ventaja de Home Assistant es que me permite integrar dispositivos de distintos fabricantes, tener toda la domótica centralizada y utilizar una única aplicación para controlar todo. En este caso, tiene la ventaja añadida de que los datos no pasan por ningún servidor ajeno, se quedan en casa.&lt;/p&gt;
&lt;h1 id=&#34;cómo-integrar-sonoff-con-home-assistant&#34;&gt;¿Cómo integrar Sonoff con Home Assistant?&lt;/h1&gt;
&lt;p&gt;&lt;a href=&#34;https://esphome.io&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;ESPHome&lt;/a&gt; es la respuesta!&lt;/p&gt;
&lt;p&gt;&lt;em&gt;ESPHome&lt;/em&gt; es un sistema que permite controlar de forma remota dispositivos &lt;em&gt;ESP8266&lt;/em&gt; y &lt;em&gt;ESP32&lt;/em&gt;. Y casualmente los dispositivos Sonoff llevan un chip ESP8266. Realmente no es casualidad, esto es algo que investigué antes de decidirme a comprar el Sonoff Pow R2. Al descubrir ESPHome y lo fácil que era integrarlo con Home Assistant, la decisión estaba clara.&lt;/p&gt;
&lt;p&gt;La integración de ESPHome con Home Assistant es muy sencilla y consiste en &lt;a href=&#34;https://esphome.io/guides/getting_started_hassio.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;instalar un add-on en Home Assistant&lt;/a&gt;. La instalación del add-on es muy sencilla pero he tenido problemas de acceso a la interfaz a través de NGINX, debidos al uso de WebSockets que hace el add-on de ESPHome. Para solucionarlo he incluído la &lt;a href=&#34;#configuraci%c3%b3n-nginx-para-websockets-de-esphome&#34;&gt;siguiente configuración en NGINX&lt;/a&gt;.&lt;/p&gt;
&lt;h1 id=&#34;programación-del-sonoff&#34;&gt;Programación del Sonoff&lt;/h1&gt;
&lt;p&gt;Para poder controlar un dispositivo con el chip ESP8266 mediante ESPHome hay que flashear en el chip un binario con el código de ESPHome. Para flashear dicho binario he utilizado &lt;a href=&#34;https://github.com/esphome/esphome-flasher/releases&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;esphome-flasher&lt;/a&gt;. En imprescindible un &lt;em&gt;adaptador serie USB a TTL&lt;/em&gt; para poder conectar el dispositivo a un PC y flashear el código. Yo he utilizado un &lt;a href=&#34;https://www.amazon.es/gp/product/B07HM7RPB7/ref=ppx_yo_dt_b_asin_title_o05_s01&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;adaptador CH340G&lt;/a&gt;. Los drivers de los adaptadores se encuentran accesibles &lt;a href=&#34;#drivers-adaptador-usb-a-ttl&#34;&gt;aquí&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&#34;cómo-obtenemos-el-binario-con-el-código-a-flashear&#34;&gt;¿Cómo obtenemos el binario con el código a flashear?&lt;/h2&gt;
&lt;p&gt;Esto es una tarea muy sencilla, gracias a ESPHome que lo simplifica al máximo. Simplemente hay que generar un fichero yaml con la configuración y comportamiento que queramos que tenga el dispositivo. ESPHome se encarga de generar un binario con el código correspondiente al contenido de dicho fichero yaml.&lt;/p&gt;
&lt;p&gt;Este es el fichero yaml que he utilizado en este caso:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;esphome:
  name: rpicluster_power
  platform: ESP8266
  board: esp01_1m

# WiFi connection
wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password

  # Enable fallback hotspot (captive portal) in case wifi connection fails
  ap:
    ssid: &amp;quot;Rpicluster Sonoff POW R2&amp;quot;
    password: &amp;quot;rpiclustersonoffpowr2&amp;quot;

# Enable logging
logger:
  baud_rate: 0

# Enable Home Assistant API
api:

# Enable over-the-air updates
ota:

# Enable Web server
web_server:
  port: 80

uart:
  rx_pin: RX
  baud_rate: 4800

sensor:
  - platform: wifi_signal
    name: &amp;quot;RPI Cluster WiFi Signal&amp;quot;
    update_interval: 15s
    icon: mdi:wifi
  - platform: uptime
    name: &amp;quot;RPI Cluster Uptime&amp;quot;
  # Power sensor
  - platform: cse7766
    update_interval: 5s
    # Current sensor
    current:
      name: &amp;quot;RPI Cluster Current&amp;quot;
      icon: mdi:current-ac
      unit_of_measurement: A
      accuracy_decimals: 3
    # Voltage sensor
    voltage:
      name: &amp;quot;RPI Cluster Voltage&amp;quot;
      icon: mdi:flash
      unit_of_measurement: V
      accuracy_decimals: 1
    # Power sensor
    power:
      name: &amp;quot;RPI Cluster Power&amp;quot;
      icon: mdi:gauge
      unit_of_measurement: W
      accuracy_decimals: 0
      id: rpiclusterpower

  - platform: total_daily_energy
    name: &amp;quot;RPI Cluster Daily Energy&amp;quot;
    power_id: rpiclusterpower
    filters:
      - multiply: 0.001
    unit_of_measurement: kWh
    icon: mdi:chart-bar

time:
  - platform: homeassistant
    id: homeassistant_time

interval:
  - interval: 10s
    then:
      if:
        condition:
          wifi.connected:
        then:
          - light.turn_on: led
        else:
          - light.turn_off: led

binary_sensor:
  # Binary sensor for the button press
  - platform: gpio
    name: &amp;quot;RPI Cluster Power Button&amp;quot;
    pin:
      number: GPIO0
      mode: INPUT_PULLUP
      inverted: true
    on_press:
      - switch.toggle: relay
  
  - platform: status
    name: &amp;quot;RPI Cluster Status&amp;quot;

switch:
  - platform: gpio
    name: &amp;quot;RPI Cluster Sonoff Relay&amp;quot;
    id: relay
    pin: GPIO12
    restore_mode: RESTORE_DEFAULT_ON

  - platform: restart
    name: &amp;quot;RPI Cluster Sonoff Restart&amp;quot;

output:
  - platform: esp8266_pwm
    id: pow_blue_led
    pin:
      number: GPIO13
      inverted: True

light:
  - platform: monochromatic
    name: &amp;quot;RPI Cluster POW Blue LED&amp;quot;
    output: pow_blue_led
    id: led

text_sensor:
  - platform: version
    name: &amp;quot;RPI Cluster POW Version&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;La información de los pines de entrada/salida del sonoff se encuentra en la &lt;a href=&#34;https://esphome.io/devices/sonoff.html#sonoff-pow-r2&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;documentación&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Quiero destacar que el sonoff únicamente hay que conectarlo al pc para flashearlo la primera vez. En el yaml anterior se habilita &lt;code&gt;OTA&lt;/code&gt; (over-the-air), lo que permite actualizar el código a través de la conexión WiFi, sin necesidad de volver a abrir el dispositivo y desmontarlo de donde estuviera.&lt;/p&gt;
&lt;h1 id=&#34;panel-de-control&#34;&gt;Panel de control&lt;/h1&gt;
&lt;p&gt;Gracias a la integración de ESPHome con Home Assistant es muy sencillo crear un panel de control como el que se ve en la siguiente imagen:&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;./resources/cluster_home_assistant_dashboard.png&#34; alt=&#34;Imagen dashboard&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;En el panel anterior se dispone de:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Consumo actual
&lt;ul&gt;
&lt;li&gt;Corriente&lt;/li&gt;
&lt;li&gt;Potencia&lt;/li&gt;
&lt;li&gt;Voltaje&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Estado
&lt;ul&gt;
&lt;li&gt;Tiempo en marcha (&lt;a href=&#34;#template-para-el-tiempo-encencido&#34;&gt;ver template en anexo&lt;/a&gt; )&lt;/li&gt;
&lt;li&gt;Versión de ESPHome en el sonoff&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Histórico de consumo&lt;/li&gt;
&lt;li&gt;Consumo diario&lt;/li&gt;
&lt;li&gt;Estado y control del led azul
&lt;ul&gt;
&lt;li&gt;Este led lo utilizo para representar la conectividad a la WiFi (encendido significa conectado)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Estado y control del relay&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;El pico de consumo de más de 1500W no se corresponde a un uso normal del cluster. Se corresonde a unas pruebas de estuve realizando para calibrar el Sonoff. La calibración del Sonoff queda fuera del ámbito de este post y lo explicaré en otro momento.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&#34;conclusión&#34;&gt;Conclusión&lt;/h1&gt;
&lt;p&gt;El principal objetivo de construir este cluster era didáctico. A día de hoy no tengo claro si esta va a ser su única finalidad o si, una vez terminado, lo voy a utilizar con otros fines, puesto que ideas no me faltan. Conocer el consumo eléctrico y su consiguiente coste económico es una variable que voy a tener muy en cuenta a la hora de decidir el uso del cluster a medio-largo plazo.&lt;/p&gt;
&lt;h1 id=&#34;anexo&#34;&gt;Anexo&lt;/h1&gt;
&lt;h2 id=&#34;configuración-nginx-para-websockets-de-esphome&#34;&gt;Configuración NGINX para WebSockets de ESPHome&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;location /api/hassio_ingress {
    resolver 127.0.0.11 valid=30s;
    # Home Assistant IP
    set $upstream_app 192.168.86.4;
    # Home Assistant Internal Port
    set $upstream_port 8123;
    # Home Assistant Internal Protocol
    set $upstream_proto http;
    proxy_pass $upstream_proto://$upstream_app:$upstream_port;

    # Home Assistant External Host:Port
    proxy_set_header Host $host:9443;

    proxy_http_version 1.1;
    proxy_set_header Upgrade $http_upgrade;
    proxy_set_header Connection &amp;quot;upgrade&amp;quot;;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;drivers-adaptador-usb-a-ttl&#34;&gt;Drivers adaptador USB a TTL&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;resources/ttl_drivers/CH340G.rar&#34;&gt;CH340G&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;resources/ttl_drivers/CP210x_Universal_Windows_Driver.zip&#34;&gt;CP210X&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;resources/ttl_drivers/PL2303_Prolific_DriverInstaller_v1_8_0.zip&#34;&gt;PL2303&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;template-para-el-tiempo-en-marcha&#34;&gt;Template para el tiempo en marcha&lt;/h2&gt;
&lt;p&gt;Por defecto el tiempo que lleva encendido el sonoff se envía en segundos. Este dispositivo está pensado para estar contínuamente encendido enviando las lecturas, independientemente de si el cluster está en marcha o no. Por este motivo no tiene mucho sentido visualizar en el panel esta información en crudo. Para transformar este dato en otro que aporte más valor he creado el siguiente template en el Home Assistant:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;sensor:
  - platform: template
    sensors:
      rpi_cluster_pow_uptime_readable:
        friendly_name: &amp;quot;RPI Cluster Uptime&amp;quot;
        icon_template: &amp;quot;mdi:timer&amp;quot;
        value_template: &amp;gt;-
          {% set uptime = states.sensor.rpi_cluster_pow_uptime.state | int %}
          {% set days = (uptime / 86400) | int %}
          {%- if days &amp;gt; 0 -%}
            {{ days }} days, {{ (uptime - (days * 86400)) | int | timestamp_custom(&#39;%H:%M:%S&#39;, false) }}
          {%- else -%}
            {{ uptime | int | timestamp_custom(&#39;%H:%M:%S&#39;, false) }}
          {%- endif -%}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Si lleva más de un día encendido, se visualizará el número de días que lleva encendido junto con las horas, minutos y segundos. Si lleva menos de un día, simplemente se visualizarán las horas, minutos y segundos.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Este template podría mejorarse aún más teniendo en cuenta meses y años&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;piezas-para-la-caja-del-cluster&#34;&gt;Piezas para la caja del cluster&lt;/h2&gt;
&lt;p&gt;Para realizar el diseño de todas las piezas he utilizado &lt;a href=&#34;https://www.onshape.com&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;OnShape&lt;/a&gt;. Todos los diseños que he realizado para la caja son públicos y encuentran disponibles &lt;a href=&#34;https://cad.onshape.com/documents?nodeId=4157ec7e4f12d21ec2893ac1&amp;amp;resourceType=folder&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;aquí&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Como se puede ver en las siguientes imágenes, las piezas para albergar el Sonoff no son las únicas que he diseñado para la caja del cluster. También he diseñado una tapa para una de las aberturas traseras y otra tapa para albergar tanto la &lt;a href=&#34;https://www.amazon.es/gp/product/B07RRY5MYZ/ref=ppx_yo_dt_b_asin_title_o06_s00&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;toma de corriente&lt;/a&gt; como la &lt;a href=&#34;https://www.amazon.es/gp/product/B01MD2AYSW/ref=ppx_yo_dt_b_asin_title_o04_s00&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;toma de red&lt;/a&gt; de todo el cluster:&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;./resources/cluster_trasera_exterior.jpg&#34; alt=&#34;Trasera cluster desde el exterior&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;./resources/cluster_trasera_interior.jpg&#34; alt=&#34;Trasera cluster desde el interior&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;Estoy muy contento con el resultado final, la verdad que ha quedado todo muy organizado y con un mínimo de cables:&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;./resources/cluster_final_frontal.jpg&#34; alt=&#34;Frontal del cluster&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
